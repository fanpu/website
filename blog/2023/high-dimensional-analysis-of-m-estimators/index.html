<!DOCTYPE html> <html lang="en"> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title>A Unified Framework for High-Dimensional Analysis of M-Estimators with Decomposable Regularizers: A Guided Walkthrough | Fan Pu Zeng</title> <meta name="author" content="Fan Pu Zeng"> <meta name="description" content="This post provides a gentle walkthrough of the paper ``A Unified Framework for High-Dimensional Analysis of \( M \)-Estimators with Decomposable Regularizers'' by Negahban, Ravikumar, Wainwright, and Yu. The main result of the paper proves that the \( \ell_2 \) difference between any regularized \(M\)-estimator and its true parameter can be bounded if the regularization function is decomposabile, and the loss function satisfies restricted strong convexity. The goal of this blog post is to provide the sufficient background for understanding the proof of this result, followed by a walkthrough of the proof itself. "> <meta name="keywords" content="fanpu, fanpu-zeng, fzeng, zengfanpu, fan-pu, zeng-fan-pu, CMU, carnegie-mellon, machine-learning, ml, theory, courses, course-reviews, computer-science, CS, SCS"> <link href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha256-DF7Zhf293AJxJNTmh5zhoYYIMs2oXitRfBjY+9L//AY=" crossorigin="anonymous"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/all.min.css" integrity="sha256-mUZM63G8m73Mcidfrv5E+Y61y7a12O5mW4ezU3bxqW4=" crossorigin="anonymous"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/academicons@1.9.1/css/academicons.min.css" integrity="sha256-i1+4qU2G2860dGGIOJscdC30s9beBXjFfzjWLjBRsBg=" crossorigin="anonymous"> <link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700%7CRoboto+Slab:100,300,400,500,700%7CMaterial+Icons"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jwarby/jekyll-pygments-themes@master/github.css" media="" id="highlight_theme_light"> <link rel="shortcut icon" href="/assets/img/favicon_new.ico%EF%B8%8F"> <link rel="stylesheet" href="/assets/css/main.css"> <link rel="canonical" href="https://fanpu.io/blog/2023/high-dimensional-analysis-of-m-estimators/"> </head> <body class="fixed-top-nav "> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/"><span class="font-weight-bold">Fan Pu </span>Zeng</a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">about</a> </li> <li class="nav-item active"> <a class="nav-link" href="/blog/">blog<span class="sr-only">(current)</span></a> </li> <li class="nav-item "> <a class="nav-link" href="/courses/">cmu course reviews</a> </li> <li class="nav-item "> <a class="nav-link" href="/cmu-online/">cmu online</a> </li> <li class="nav-item "> <a class="nav-link" href="/projects/">projects</a> </li> <li class="nav-item "> <a class="nav-link" href="/repositories/">repositories</a> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="container mt-5"> <div style="display:none"> $$ \DeclareMathOperator*{\argmax}{arg\,max} \DeclareMathOperator*{\argmin}{arg\,min} \newcommand{\nnz}[1]{\mbox{nnz}(#1)} \newcommand{\dotprod}[2]{\langle #1, #2 \rangle} \DeclareMathOperator*{\Pr}{\mathbf{Pr}} \DeclareMathOperator*{\E}{\mathbf{E}} \DeclareMathOperator*{\Ex}{\mathbf{E}} \DeclareMathOperator*{\Var}{\mathbf{Var}} \DeclareMathOperator*{\Cov}{\mathbf{Cov}} \DeclareMathOperator*{\stddev}{\mathbf{stddev}} \DeclareMathOperator{\littlesum} \DeclareMathOperator{\littleprod} \DeclareMathOperator*{\avg}{avg} % environments \declaretheorem[numberwithin=section]{theorem} \declaretheorem[sibling=theorem]{lemma} \declaretheorem[sibling=theorem]{claim} \declaretheorem[sibling=theorem]{proposition} \declaretheorem[sibling=theorem]{fact} \declaretheorem[sibling=theorem]{corollary} \declaretheorem[sibling=theorem]{conjecture} \declaretheorem[sibling=theorem]{question} \declaretheorem[sibling=theorem]{answer} \declaretheorem[sibling=theorem]{solution} \declaretheorem[sibling=theorem]{hypothesis} \declaretheorem[sibling=theorem]{exercise} \theoremstyle{definition} \declaretheorem[sibling=theorem]{definition} \declaretheorem[sibling=theorem]{remark} \declaretheorem[sibling=theorem]{notation} \declaretheorem[sibling=theorem]{observation} \declaretheorem[sibling=theorem]{example} \newcommand{\ignore}[1]{} % probability type operators \let\Pr\relax \DeclareMathOperator*{\Pr}{\mathbf{Pr}} \DeclareMathOperator*{\E}{\mathbf{E}} \DeclareMathOperator*{\Ex}{\mathbf{E}} \DeclareMathOperator*{\Var}{\mathbf{Var}} \DeclareMathOperator*{\Cov}{\mathbf{Cov}} \DeclareMathOperator*{\stddev}{\mathbf{stddev}} \DeclareMathOperator{\littlesum} \DeclareMathOperator{\littleprod} \DeclareMathOperator*{\avg}{avg} % math terms \DeclareMathOperator{\poly}{poly} \DeclareMathOperator{\polylog}{polylog} \DeclareMathOperator{\size}{size} \DeclareMathOperator{\sgn}{sgn} \DeclareMathOperator{\dist}{dist} \DeclareMathOperator{\vol}{vol} \DeclareMathOperator{\spn}{span} \DeclareMathOperator{\supp}{supp} \DeclareMathOperator{\tr}{tr} \DeclareMathOperator{\Tr}{Tr} \DeclareMathOperator{\codim}{codim} \DeclareMathOperator{\diag}{diag} % number systems \newcommand{\R}{\mathbb R} \newcommand{\C}{\mathbb C} \newcommand{\N}{\mathbb N} \newcommand{\Z}{\mathbb Z} \newcommand{\F}{\mathbb F} \newcommand{\Q}{\mathbb Q} % complexity classes \newcommand{\PTIME}{\mathsf{P}} \newcommand{\LOGSPACE}{\mathsf{L}} \newcommand{\ZPP}{\mathsf{ZPP}} \newcommand{\RP}{\mathsf{RP}} \newcommand{\BPP}{\mathsf{BPP}} \newcommand{\P}{\mathsf{P}} \newcommand{\NP}{\mathsf{NP}} \newcommand{\TC}{\mathsf{TC}} \newcommand{\AC}{\mathsf{AC}} \newcommand{\SC}{\mathsf{SC}} \newcommand{\SZK}{\mathsf{SZK}} \newcommand{\AM}{\mathsf{AM}} \newcommand{\IP}{\mathsf{IP}} \newcommand{\PSPACE}{\mathsf{PSPACE}} \newcommand{\EXP}{\mathsf{EXP}} \newcommand{\MIP}{\mathsf{MIP}} \newcommand{\NEXP}{\mathsf{NEXP}} \newcommand{\BQP}{\mathsf{BQP}} \newcommand{\distP}{\mathsf{dist\textbf{P}}} \newcommand{\distNP}{\mathsf{dist\textbf{NP}}} % short forms \newcommand{\eps}{\epsilon} \newcommand{\lam}{\lambda} \newcommand{\dleta}{\delta} \newcommand{\simga}{\sigma} \newcommand{\vphi}{\varphi} \newcommand{\la}{\langle} \newcommand{\ra}{\rangle} \newcommand{\wt}[1]{\widetilde{#1}} \newcommand{\wh}[1]{\widehat{#1}} \newcommand{\ol}[1]{\overline{#1}} \newcommand{\ul}[1]{\underline{#1}} \newcommand{\ot}{\otimes} \newcommand{\zo}{\{0,1\}} \newcommand{\co}{:} %\newcommand{\co}{\colon} \newcommand{\bdry}{\partial} \newcommand{\grad}{\nabla} \newcommand{\transp}{^\intercal} \newcommand{\inv}{^{-1}} \newcommand{\symmdiff}{\triangle} \newcommand{\symdiff}{\symmdiff} \newcommand{\half}{\tfrac{1}{2}} \newcommand{\bbone}{\mathbbm 1} \newcommand{\Id}{\bbone} \newcommand{\SAT}{\mathsf{SAT}} % calligraphic letters \newcommand{\calA}{\mathcal{A}} \newcommand{\calB}{\mathcal{B}} \newcommand{\calC}{\mathcal{C}} \newcommand{\calD}{\mathcal{D}} \newcommand{\calE}{\mathcal{E}} \newcommand{\calF}{\mathcal{F}} \newcommand{\calG}{\mathcal{G}} \newcommand{\calH}{\mathcal{H}} \newcommand{\calI}{\mathcal{I}} \newcommand{\calJ}{\mathcal{J}} \newcommand{\calK}{\mathcal{K}} \newcommand{\calL}{\mathcal{L}} \newcommand{\calM}{\mathcal{M}} \newcommand{\calN}{\mathcal{N}} \newcommand{\calO}{\mathcal{O}} \newcommand{\calP}{\mathcal{P}} \newcommand{\calQ}{\mathcal{Q}} \newcommand{\calR}{\mathcal{R}} \newcommand{\calS}{\mathcal{S}} \newcommand{\calT}{\mathcal{T}} \newcommand{\calU}{\mathcal{U}} \newcommand{\calV}{\mathcal{V}} \newcommand{\calW}{\mathcal{W}} \newcommand{\calX}{\mathcal{X}} \newcommand{\calY}{\mathcal{Y}} \newcommand{\calZ}{\mathcal{Z}} % bold \newcommand{\bone}{\boldsymbol{1}} \newcommand{\bbeta}{\boldsymbol{\beta}} \newcommand{\bdelta}{\boldsymbol{\delta}} \newcommand{\bepsilon}{\boldsymbol{\epsilon}} \newcommand{\blambda}{\boldsymbol{\lambda}} \newcommand{\bomega}{\boldsymbol{\omega}} \newcommand{\bpi}{\boldsymbol{\pi}} \newcommand{\bphi}{\boldsymbol{\phi}} \newcommand{\bvphi}{\boldsymbol{\varphi}} \newcommand{\bpsi}{\boldsymbol{\psi}} \newcommand{\bsigma}{\boldsymbol{\sigma}} \newcommand{\btheta}{\boldsymbol{\theta}} \newcommand{\btau}{\boldsymbol{\tau}} \newcommand{\ba}{\boldsymbol{a}} \newcommand{\bb}{\boldsymbol{b}} \newcommand{\bc}{\boldsymbol{c}} \newcommand{\bd}{\boldsymbol{d}} \newcommand{\be}{\boldsymbol{e}} \newcommand{\boldf}{\boldsymbol{f}} \newcommand{\bg}{\boldsymbol{g}} \newcommand{\bh}{\boldsymbol{h}} \newcommand{\bi}{\boldsymbol{i}} \newcommand{\bj}{\boldsymbol{j}} \newcommand{\bk}{\boldsymbol{k}} \newcommand{\bell}{\boldsymbol{\ell}} \newcommand{\bm}{\boldsymbol{m}} \newcommand{\bn}{\boldsymbol{n}} \newcommand{\bo}{\boldsymbol{o}} \newcommand{\bp}{\boldsymbol{p}} \newcommand{\bq}{\boldsymbol{q}} \newcommand{\br}{\boldsymbol{r}} \newcommand{\bs}{\boldsymbol{s}} \newcommand{\bt}{\boldsymbol{t}} \newcommand{\bu}{\boldsymbol{u}} \newcommand{\bv}{\boldsymbol{v}} \newcommand{\bw}{\boldsymbol{w}} \newcommand{\bx}{\boldsymbol{x}} \newcommand{\by}{\boldsymbol{y}} \newcommand{\bz}{\boldsymbol{z}} \newcommand{\bA}{\boldsymbol{A}} \newcommand{\bB}{\boldsymbol{B}} \newcommand{\bC}{\boldsymbol{C}} \newcommand{\bD}{\boldsymbol{D}} \newcommand{\bE}{\boldsymbol{E}} \newcommand{\bF}{\boldsymbol{F}} \newcommand{\bG}{\boldsymbol{G}} \newcommand{\bH}{\boldsymbol{H}} \newcommand{\bI}{\boldsymbol{I}} \newcommand{\bJ}{\boldsymbol{J}} \newcommand{\bK}{\boldsymbol{K}} \newcommand{\bL}{\boldsymbol{L}} \newcommand{\bM}{\boldsymbol{M}} \newcommand{\bN}{\boldsymbol{N}} \newcommand{\bP}{\boldsymbol{P}} \newcommand{\bQ}{\boldsymbol{Q}} \newcommand{\bR}{\boldsymbol{R}} \newcommand{\bS}{\boldsymbol{S}} \newcommand{\bT}{\boldsymbol{T}} \newcommand{\bU}{\boldsymbol{U}} \newcommand{\bV}{\boldsymbol{V}} \newcommand{\bW}{\boldsymbol{W}} \newcommand{\bX}{\boldsymbol{X}} \newcommand{\bY}{\boldsymbol{Y}} \newcommand{\bZ}{\boldsymbol{Z}} % others \newcommand{\false}} \newcommand{\true}} % bold calligraphic \newcommand{\bcalG}{\boldsymbol{\calG}} \newcommand{\calbG}{\bcalG} \newcommand{\bcalX}{\boldsymbol{\calX}} \newcommand{\calbX}{\bcalX} \newcommand{\bcalY}{\boldsymbol{\calY}} \newcommand{\calbY}{\bcalY} \newcommand{\bcalZ}{\boldsymbol{\calZ}} \newcommand{\calbZ}{\bcalZ} % left-right wrappers \DeclarePairedDelimiter\parens{\lparen}{\rparen} \DeclarePairedDelimiter\abs{\lvert}{\rvert} \DeclarePairedDelimiter\norm{\lVert}{\rVert} \DeclarePairedDelimiter\floor{\lfloor}{\rfloor} \DeclarePairedDelimiter\ceil{\lceil}{\rceil} \DeclarePairedDelimiter\braces{\lbrace}{\rbrace} \DeclarePairedDelimiter\bracks{\lbrack}{\rbrack} \DeclarePairedDelimiter\angles{\langle}{\rangle} % something for figures \newcommand{\myfig}[4]{\begin{figure}[H] \centering \includegraphics[width=#1\textwidth]{#2} \caption{#3} \label{#4} \end{figure}} \definecolor{codegreen}{rgb}{0,0.6,0} \definecolor{codegray}{rgb}{0.5,0.5,0.5} \definecolor{codepurple}{rgb}{0.58,0,0.82} \definecolor{backcolour}{rgb}{0.95,0.95,0.92} \lstdefinestyle{mystyle}{ backgroundcolor=\color{backcolour}, commentstyle=\color{codegreen}, keywordstyle=\color{magenta}, numberstyle=\tiny\color{codegray}, stringstyle=\color{codepurple}, basicstyle=\ttfamily\footnotesize, breakatwhitespace=false, breaklines=true, captionpos=b, keepspaces=true, numbers=left, numbersep=5pt, showspaces=false, showstringspaces=false, showtabs=false, tabsize=2 } \lstset{style=mystyle} $$ </div> <div class="post"> <header class="post-header"> <h1 class="post-title">A Unified Framework for High-Dimensional Analysis of M-Estimators with Decomposable Regularizers: A Guided Walkthrough</h1> <p class="post-meta">June 2, 2023• fanpu</p> <p class="post-tags"> <a href="/blog/2023"> <i class="fas fa-calendar fa-sm"></i> 2023 </a>   ·   <a href="/blog/tag/machine-learning"> <i class="fas fa-hashtag fa-sm"></i> machine-learning</a>   <a href="/blog/tag/statistics"> <i class="fas fa-hashtag fa-sm"></i> statistics</a>   </p> </header> <figure> <picture> <img src="/assets/img/posts/dionysus_delphi.jpg" class="preview z-depth-1 rounded center" width="100%" height="450px" alt="post.cover" style="object-fit: cover" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> <div class="caption"> Theatre of Dionysus at Delphi, Greece </div> <article class="post-content"> <ul id="toc" class="section-nav"> <li class="toc-entry toc-h1"><a href="#introduction">Introduction</a></li> <li class="toc-entry toc-h1"> <a href="#background">Background</a> <ul> <li class="toc-entry toc-h2"><a href="#regularized-m-estimators">Regularized \(M\)-estimators</a></li> <li class="toc-entry toc-h2"><a href="#dual-norms">Dual Norms</a></li> <li class="toc-entry toc-h2"><a href="#subspace-compatibility-constant">Subspace Compatibility Constant</a></li> <li class="toc-entry toc-h2"><a href="#projections-todo-check-label-labelsecprojection">Projections [TODO check label] \label{sec:projection}</a></li> </ul> </li> <li class="toc-entry toc-h1"><a href="#problem-formulation">Problem Formulation</a></li> <li class="toc-entry toc-h1"> <a href="#decomposability-of-the-regularizer-mathcalr">Decomposability of the Regularizer \(\mathcal{R}\)</a> <ul> <li class="toc-entry toc-h2"><a href="#role-of-decomposability">Role of Decomposability</a></li> <li class="toc-entry toc-h2"><a href="#restricted-strong-convexity-rsc-of-the-loss-function">Restricted Strong Convexity (RSC) of the Loss Function</a></li> <li class="toc-entry toc-h2"><a href="#proof-of-theorem-1-todo-check-labelsecthm1-proof">Proof of Theorem 1 [TODO check] \label{sec:thm1-proof}</a></li> </ul> </li> <li class="toc-entry toc-h1"><a href="#conclusion">Conclusion</a></li> <li class="toc-entry toc-h1"><a href="#slides">Slides</a></li> <li class="toc-entry toc-h1"><a href="#citations">Citations</a></li> </ul>\[\newcommand{\rcal}{\mathcal{R}} \newcommand{\lcal}{\mathcal{L}} \newcommand{\mcal}{\mathcal{M}} \newcommand{\mocal}{\overline{\mathcal{M}}} \newcommand{\mocalp}{\overline{\mathcal{M}}^\perp} \newcommand{\mcalp}{\mathcal{M}^\perp} \newcommand{\sse}{\subseteq} \newcommand{\kl}{\kappa_{\lcal}} \newcommand{\tl}{\tau_{\lcal}} \newcommand{\ts}{\theta^*} \newcommand{\hd}{\widehat{\Delta}} \newcommand{\thatn}{\hat{\theta}_n} \newcommand{\that}{\hat{\theta}} \newcommand{\thatlambda}{\widehat{\theta}_{\lambda_n}} \newcommand{\thatl}{\thatlambda} \newcommand{\rs}{\rcal^*} \newcommand{\ctriplet}{ \C(\mcal, \mocalp; \ts) } \newcommand{\fcal}{\mathcal{F}} \newcommand{\kbb}{\mathbb{K}}\] <p>TODO: on page 16 of the slides, change the 2 to s for the second equation</p> <h1 id="introduction"> <a class="anchor" href="#introduction" aria-hidden="true"><span class="octicon octicon-link"></span></a>Introduction</h1> <p>In high-dimensional statistical inference, it is common for the number of parameters \(p\) to be comparable to or greater than the sample size \(n\). However, for an estimator \(\thatn\) to be consistent in such a regime, meaning that it converges to the true parameter \(\theta\), it is necessary to make additional low-dimensional assumptions on the model. Examples of such constraints that have been well-studied include linear regression with sparsity constraints, estimation of structured covariance or inverse covariance matrices, graphical model selection, sparse principal component analysis (PCA), low-rank matrix estimation, matrix decomposition problems and estimation of sparse additive nonparametric models \cite{paper}.</p> <p>In recent years, there has been a flurry of work on each of these individual specific cases. However, the authors of the paper in discussion poses the question of whether there is a way of unifying these analysis to understand all of such estimators in a common framework, and answers it in the affirmative. They showed that it is possible to bound the squared difference between any regularized \(M\)-estimator and its true parameter by (1) the decomposability of the regularization function, and (2) restricted strong convexity of the loss function. We will call this the “main theorem” in the remainder of the blog post, and this is referred to as ``Theorem 1’’ in \(\cite{paper}\).</p> <p>In the remainder of the paper, we will develop the tools necessary to deeply understand and prove the result. Notation used will be consistent with the original paper for expositional clarity.</p> <h1 id="background"> <a class="anchor" href="#background" aria-hidden="true"><span class="octicon octicon-link"></span></a>Background</h1> <p>In this section, we develop some of the necessary background and notation to build up to the proof.</p> <h2 id="regularized-m-estimators"> <a class="anchor" href="#regularized-m-estimators" aria-hidden="true"><span class="octicon octicon-link"></span></a>Regularized \(M\)-estimators</h2> <p>\(M\)-estimators (\(M\) for ``maximum likelihood-type’’) are solutions that minimize the sum of loss functions \(\rho\): \begin{align} \that \in \argmin_\theta \sum_{i=1}^n \rho(x_i, \theta). \end{align}</p> <p>If we add a regularization term \(\rcal\) to penalize complexity of the model, scaled by weights \(\lambda\), the method is known as a regularized \(M\)-estimator: \begin{align} \that \in \argmin_\theta \sum_{i=1}^n \rho(x_i, \theta) + \lambda \rcal(\theta). \end{align}</p> <div class="example"> <div class="theorem-title">Example (Lasso Program) </div> <div class="theorem-contents"> The Lasso program is an example of a regularized \( M \)-estimator, where a \( \ell_1 \) regurization penalty is applied: $$ \that \in \argmin_{\theta \in \R^d} \left\{ \frac{1}{2n} \| y - \bX \theta \|_2^2 + \lambda_n \| \theta \|_1 \right\}. $$ </div> </div> <h2 id="dual-norms"> <a class="anchor" href="#dual-norms" aria-hidden="true"><span class="octicon octicon-link"></span></a>Dual Norms</h2> <div class="definition"> <div class="theorem-title">Definition (Dual Norms) </div> <div class="theorem-contents"> Let \(\rcal\) be a norm induced by an inner product \(\dotprod{\cdot}{\cdot}\). Then the dual norm of \(\rcal\) is defined as $$ \rs(v) \coloneqq \sup_{u \in \R^p \setminus \left\{ 0 \right\}} \frac{ \dotprod{u}{v} }{\rcal (u)} = \sup_{\rcal(u) \leq 1} \dotprod{u}{v}. $$ </div> </div> <div class="example"> <div class="theorem-title">Example (\(\ell_1\) and \(\ell_\infty\) norms are dual norms) </div> <div class="theorem-contents"> We will show that the dual of the \( \ell_1 \) norm is the \( \ell_\infty \) norm. Well, to see that \( \rs(v) \leq \| v \|_\infty \), observe that \begin{align*} \rs(v) &amp; = \sup_{\| u \|_1 \leq 1} \dotprod{u}{v} \\ &amp; = \sup_{\| u \|_1 \leq 1} \sum_{k=1}^p | u_k | | v_k | \\ &amp; \leq \sup_{\| u \|_1 \leq 1} \left( \sum_{k=1}^p | u_k | \right) \| v \|_\infty \\ &amp; = | v |_\infty \tag{since \( \| u \|_1 \leq 1 \) }. \end{align*} For the opposite direction, \begin{align*} \sup_{\| u \|_1 \leq 1} \dotprod{u}{v} &amp; = \sup_{\| u \|_1 \leq 1} \sum_{k=1}^p |u_k| |v_k| \\ &amp; \geq 1 \cdot |v_j| \tag{ set \( j = \argmax_j |v_j|, u = \be_j \) } \\ &amp; = \| v \|_\infty, \end{align*} hence we have equality. </div> </div> <h2 id="subspace-compatibility-constant"> <a class="anchor" href="#subspace-compatibility-constant" aria-hidden="true"><span class="octicon octicon-link"></span></a>Subspace Compatibility Constant</h2> <p>The subspace compatibility constant measures how much the regularizer \(\rcal\) can change with respect to the error norm \(\| \cdot \|\) restricted to the subspace \(\mcal\). This concept will show up later in showing that the restricted strong convexity condition will hold with certain parameters.</p> <p>The subspace compatibility constant is defined as follows:</p> <div class="definition"> <div class="theorem-title">Definition (Subspace Compatibility Constant) </div> <div class="theorem-contents"> For any subspace \( \mcal \) of \( \R^p \), the \textit{subspace compatibility constant} with respect to the pair \( (\rcal, \| \cdot \|) \) is given by \begin{align} \varPsi (\mcal) \coloneqq \sup_{u \in \mcal \setminus \left\{ 0 \right\}} \frac{\rcal(u)}{\| u \|}. \end{align} </div> </div> <p>It can be thought of as the Lipschitz constant of the regularizer with respect to the error norm restricted to values in \(\mcal\), by considering the point where it can vary the most.</p> <h2 id="projections-todo-check-label-labelsecprojection"> <a class="anchor" href="#projections-todo-check-label-labelsecprojection" aria-hidden="true"><span class="octicon octicon-link"></span></a>Projections [TODO check label] \label{sec:projection}</h2> <p>Define the projection operator \begin{align} \Pi_{\mcal}(u) \coloneqq \argmin_{v \in \mcal} | u - v | \end{align} to be the projection of \(u\) onto the subspace \(\mcal\). For notational brevity, we will use the shorthand \(u_{\mcal} = \Pi_{\mcal}(u)\).</p> <p>One property of the projection operator is that it is non-expansive, meaning that \begin{align} | \Pi(u) - \Pi(v) | \leq | u - v | \label{eq:non-expansive} \end{align} for some error norm \(\| \cdot \|\). In other words, it has Lipschitz constant 1.</p> <h1 id="problem-formulation"> <a class="anchor" href="#problem-formulation" aria-hidden="true"><span class="octicon octicon-link"></span></a>Problem Formulation</h1> <p>In our setup, we define the following quantities:</p> <ul> <li>\(Z_1^n \coloneqq \left\{ Z_1, \cdots, Z_n \right\}\) \(n\) i.i.d observations drawn from distribution \(\mathbb{P}\) with some parameter \(\theta^*\),</li> <li>\(\mathcal{L}: \mathbb{R}^p \times \mathcal{Z}^n \to \mathbb{R}\) a convex and differentiable loss function, such that \(\mathcal{L}(\theta; Z_1^n)\) returns the loss of \(\theta\) on observations \(Z_1^n\),</li> <li>\(\lambda_n &gt; 0\): a user-defined regularization penalty,</li> <li>\(\mathcal{R} : \R^p \to \R_+\) a norm-based regularizer.</li> </ul> <p>The purpose of the regularized \(M\)-estimator is then to solve for the convex optimization problem</p> \[\begin{align} \label{eq:opt} \widehat{\theta}_{\lambda_n} \in \argmin_{\theta \in \R^p} \left\{ \mathcal{L}(\theta; Z_1^n) + \lambda_n \mathcal{R} (\theta) \right\}, \end{align}\] <p>and we are interested in deriving bounds on \(\begin{align} \| \thatlambda - \theta^* \| \end{align}\) for some error norm \(\| \cdot \|\) induced by an inner product \(\langle \cdot, \cdot \rangle\) in \(\R^p\).</p> <h1 id="decomposability-of-the-regularizer-mathcalr"> <a class="anchor" href="#decomposability-of-the-regularizer-mathcalr" aria-hidden="true"><span class="octicon octicon-link"></span></a>Decomposability of the Regularizer \(\mathcal{R}\)</h1> <p>The first key property in the result is decomposability of our norm-based regularizer \(\rcal\). Working in the ambient \(\R^p\), define \(\mcal \sse \R^p\) to be the model subspace that captures the constraints of the model that we are working with (i.e \(k\)-sparse vectors), and denote \(\mocal\) to be its closure, i.e the union of \(\mcal\) and all of its limit points. In addition, denote \(\mocalp\) to be the orthogonal complement of \(\mocal\), namely</p> \[\begin{align} \mocalp \coloneqq \left\{ v \in \R^p \mid \langle u, v \rangle = 0 \text{ for all \( u \in \mocal \) } \right\}. \end{align}\] <p>We call this the perturbation subspace, as they represent perturbations away from the model subspace \(\mocal\). The reason why we need to consider \(\mocal\) instead of \(\mcal\) is because there are some special cases of low-rank matrices and nuclear norms where it could be possible that \(\mcal\) is strictly contained in \(\mocal\).</p> <p>Now we can introduce the property of decomposability:</p> <div class="definition"> <div class="theorem-title">Definition (Regularizer Decomposability) </div> <div class="theorem-contents"> Given a pair of subspaces \( \mcal \sse \mocal \), a norm-based regularizer \( \rcal \) is \textit{decomposable} with respect to \( (\mocal, \mocalp) \) if \begin{align} \rcal(\theta + \gamma) = \rcal(\theta) + \rcal(\gamma) \end{align} for all \( \theta \in \mcal \) and \( \gamma \in \mocalp \). </div> </div> <p>Since \(\rcal\) is a norm-based regularizer, by the triangle inequality property of norms we know that always \begin{align} \rcal(\theta + \gamma) \leq \rcal(\theta) + \rcal(\gamma), \end{align} and hence this is a stronger condition which requires tightness in the inequality when we are specifically considering elements in the closure of the model subspace and its orthogonal complement.</p> <p>Decomposability of the regularizer is important as it allows us to penalize deviations \(\gamma\) away from the model subspace in \(\mcal\) to the maximum extent possible. We are usually interested to find model subspaces that are small, with a large orthogonal complement. We will see in the main theorem that when this is the case, we will obtain better rates for estimating \(\theta^*\).</p> <p>There are many natural contexts that admit regularizers which are decomposable with respect to subspaces, and the following example highlights one such case.</p> <div class="example"> <div class="theorem-title">Example (\( s \)-sparse Vectors) </div> <div class="theorem-contents"> Consider estimating the parameters \( \that \) with \( \ell_1 \)-regularization in \( \R^p \) where we assume that the model is \( s \)-sparse. Then for any set \( S \sse [p] \) where \( |S| = s \), we can define our model subspace \( \mcal \) as \[ \begin{align} \mcal(S) \coloneqq \left\{ \theta \in \R^p \mid \theta_j = 0 \quad \forall j \not\in S \right\}, \end{align} \] i.e all the vectors in \( \R^p \) that only has support in \( S \). In this case, \( \mcal = \mocal \), and our orthogonal complement \( \mocalp \) is just \[ \begin{align} \mocalp(S) \coloneqq \left\{ \gamma \in \R^p \mid \gamma_j = 0 \quad \forall j \in S \right\}. \end{align} \] Then this setup is decomposable: \[ \begin{align} \| \theta + \gamma \|_1 = \| \theta_S + \gamma_{S^c} \|_1 = \| \theta_S \|_1 + \| \gamma_{S^c} \| = \| \theta \|_1 + \| \gamma \|_1 \end{align} \] by the Pythagorean theorem. </div> </div> <h2 id="role-of-decomposability"> <a class="anchor" href="#role-of-decomposability" aria-hidden="true"><span class="octicon octicon-link"></span></a>Role of Decomposability</h2> <figure> <picture> <img src="/assets/img/posts/high-dimensional-analysis-of-m-estimators/c_illust.png" class="z-depth-1 center" width="500px" height="auto" style="object-fit: cover" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture><figcaption class="caption"> A visualization of \( \ctriplet \). The shaded area represents the set \( \ctriplet \), i.e all values of \( \theta \) that satisfies the inequality in Equation \ref{eq:c}. </figcaption> </figure> <p>Decomposability is important because it allows us to bound the error of the estimator. This is given in the following result, which is known as Lemma 1 in \cite{paper}:</p> <div class="lemma"> <div class="theorem-title">Lemma (Lemma 1 in \cite{paper}) </div> <div class="theorem-contents"> Suppose that \( \lcal \) is a convex and differentiable function, and consider any optimal solution \( \that \) to the optimization problem with a strictly positive regularization parameter satisfying $$ \begin{align} \lambda_n \geq 2 \rcal^* (\nabla \lcal (\ts; Z_1^n)). \end{align} $$ Then for any pair \( (\mcal, \mocalp) \) over which \( \rcal \) is decomposable, the error \( \hd = \thatlambda - \ts \) belongs to the set $$ \begin{align} \label{eq:c} \C(\mcal, \mocalp; \ts) \coloneqq \left\{ \Delta \in \R^p \mid \rcal(\Delta_{\mocalp}) \leq 3 \rcal (\Delta_{\mocal}) + 4 \rcal (\ts_{\mcalp}) \right\}. \end{align} $$ </div> </div> <p>Recall from Section \ref{sec:projection} that \(\Delta_{\mocalp}\) represents the projection of \(\Delta\) onto \(\mocalp\), and similarly for the other quantities. Due to space constraints we are unable to prove Lemma \ref{lemma:1} in this survey, but it is very important in the formulation of restricted strong convexity, and in proving Theorem \ref{thm:1}.</p> <p>Figure \ref{fig:cone} provides a visualization of \(\ctriplet\) in \(\R^3\) in the sparse vectors setting. In this case, \(S = \left\{ 3 \right\}\) with \(|S|=1\), and so the projection of \(\Delta\) onto the model subspace only has non-zero values on the third coordinate, and its orthogonal complement is where the third coordinate is zero. Formally,</p> \[\begin{align} \mcal(S) = \mocal(S) &amp; = \left\{ \Delta \in \R^3 \mid \Delta_1 = \Delta_2 = 0 \right\}, \\ \mocalp(S) &amp; = \left\{ \Delta \in \R^3 \mid \Delta_3 = 0 \right\}. \end{align}\] <p>The vertical axis of Figure \ref{fig:cone} denotes the third coordinate, and the horizontal plane denotes the first two coordinates. The shaded area represents the set \(\ctriplet\), i.e all values of \(\theta\) that satisfies the inequality in Equation \ref{eq:c}.</p> <p>Figure \ref{fig:cone}(a) shows the special case when \(\ts \in \mcal\). In this scenario, \(\rcal (\ts_{\mcalp}) = 0\), and so</p> \[\begin{align*} \C(\mcal, \mocalp; \ts) = \left\{ \Delta \in \R^p \mid \rcal(\Delta_{\mocalp}) \leq 3 \rcal (\Delta_{\mocal}) \right\}, \end{align*}\] <p>which is a cone.</p> <p>However, in the general setting where \(\ts \not\in \mcal\), then \(\rcal (\ts_{\mcalp}) &gt; 0\), and the set \(\ctriplet\) will become a star-shaped set like what is shown in Figure \ref{fig:cone}(b).</p> <h2 id="restricted-strong-convexity-rsc-of-the-loss-function"> <a class="anchor" href="#restricted-strong-convexity-rsc-of-the-loss-function" aria-hidden="true"><span class="octicon octicon-link"></span></a>Restricted Strong Convexity (RSC) of the Loss Function</h2> <figure> <picture> <img src="/assets/img/posts/high-dimensional-analysis-of-m-estimators/curvature.png" class="z-depth-1 center" width="500px" height="auto" style="object-fit: cover" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture><figcaption class="caption"> An illustration of the role of curvature in guaranteeing that \( \hd = \thatlambda - \ts \) is small when \( \lcal(\thatlambda) - \lcal(\ts) \) is small. </figcaption> </figure> <p>In a classical setting, as the number of samples \(n\) increases, the difference in loss \(d \lcal = |\lcal(\thatlambda) - \lcal(\ts)|\) will converge to zero. However, the convergence in loss by itself is insufficient to also ensure the convergence in parameters, \(\hd = \thatlambda - \ts\). Instead, it also depends on the curvature of the loss function \(\lcal\).</p> <p>Figure \ref{fig:curvature} illustrates the importance of curvature. In Figure \ref{fig:curvature}(a), \(\lcal\) has high curvature, and so having a small \(d\lcal\) also implies a small \(\hd\). On the other hand, in Figure \ref{fig:curvature}(b), \(\lcal\) has an almost flat landscape near \(\thatlambda\), and hence even when \(d \lcal\) is small, \(\hd\) could still be large.</p> <p>Consider performing a Taylor expansion of \(\lcal\) around \(\ts\):</p> \[\begin{align} \lcal(\ts + \Delta) &amp; = \lcal(\ts) + \dotprod{\nabla \lcal(\ts)}{\Delta} + \underbrace{\frac{1}{2} \Delta^T \nabla^2 \lcal(\ts) \Delta + \dots}_{\delta \lcal(\Delta, \ts)}. \end{align}\] <p>Then we can rearrange and write the error of the first-order Taylor series expansion at \(\ts\) as</p> \[\begin{align*} \delta \lcal(\Delta, \ts) = \lcal(\ts + \Delta) - \lcal(\ts) - \dotprod{\nabla \lcal(\ts)}{\Delta}. \end{align*}\] <p>The first-order Taylor approximation is a linear approximation, and hence the error \(\delta \lcal(\Delta, \ts)\), which is dominated by the quadratic term, can capture the curvature about \(\ts\).</p> <p>As such, one way to show that \(\lcal\) has good curvature about \(\ts\) is to show that \(\delta \lcal(\Delta, \ts) \geq \kappa \|\Delta \|^2\) holds for all \(\Delta\) in a neighborhood of \(\ts\). This is because we are enforcing a lower bound on its quadratic growth.</p> <p>This leads us to the definition of restricted strong convexity:</p> <div class="definition"> <div class="theorem-title">Definition (Restricted Strong Convexity) </div> <div class="theorem-contents"> The loss function satisfies a \textit{restricted strong convexity} (RSC) condition with curvature \( \kl &gt; 0 \) and tolerance function \( \tl \) if \begin{align} \delta \lcal(\Delta, \ts) \geq \kl \| \Delta \|^2 - \tl^2(\ts) \end{align} for all \( \Delta \in \ctriplet \). </div> </div> <p>We only need to consider error terms \(\Delta \in \ctriplet\), since Lemma \ref{lemma:1} guarantees us that the error term will only lie in that set.</p> <p>In many statistical models, restricted strong convexity holds with \(\tl = 0\), however it is required in more general settings, such as generalized linear models.</p> <h2 id="proof-of-theorem-1-todo-check-labelsecthm1-proof"> <a class="anchor" href="#proof-of-theorem-1-todo-check-labelsecthm1-proof" aria-hidden="true"><span class="octicon octicon-link"></span></a>Proof of Theorem 1 [TODO check] \label{sec:thm1-proof}</h2> <p>We can now state and prove the main result of the paper. This will hold under the decomposability of the regularizer (G1), and the restricted strong convexity of the loss function (G2).</p> <ul> <li> <p><strong>(G1)</strong> The regularizer \(\rcal\) is a norm and is decomposable with respect to the subspace pair \((\mcal, \mocalp)\), where \(\mcal \sse \mocalp\).</p> </li> <li> <p><strong>(G2)</strong> The loss function \(\lcal\) is convex and differentiable, and satisfies restricted strong convexity with curvature \(\kl\) and tolerance \(\tl\).</p> </li> </ul> <div class="theorem"> <div class="theorem-title">Theorem 1 in (Negahban et al., 2009) (Bounds for General Models) </div> <div class="theorem-contents"> Under conditions (G1) and (G2), consider the convex optimization problem (\ref{eq:opt}) based on a strictly positive positive regularization constant \( \lambda_n \geq 2 \rs (\nabla \lcal (\ts)) \). Then any optimal solution \( \thatlambda \) to the convex program (\ref{eq:opt}) satisfies the bound \begin{align} \| \thatlambda - \ts \|^2 \leq 9 \frac{\lambda_n^2}{\kl^2} \Psi^2(\mocal) + \frac{\lambda_n}{\kl} \left( 2 \tl^2 (\ts) + 4 \rcal (\ts_{\mcal^{\perp}}) \right). \end{align} </div> </div> <p>We will rely on the following lemmas that will be stated without proof due to space constraints:</p> <div class="lemma"> <div class="theorem-title">Lemma 3 in (Negahban et al., 2009) (Deviation Inequalities) </div> <div class="theorem-contents"> For any decomposable regularizer and \( p \)-dimensional vectors \( \ts \) and \( \Delta \), we have \begin{align} \rcal(\ts + \Delta) - \rcal(\ts) \geq \rcal(\Delta_{\mocalp}) - \rcal(\Delta_{\mocal}) - 2 \rcal(\ts_{\mcal^{\perp}}). \end{align} Moreover, as long as \( \lambda_n \geq 2 \rs (\nabla \lcal(\ts)) \) and \( \lcal \) is convex, we have \begin{align} \lcal(\ts + \Delta) - \lcal(\ts) \geq - \frac{\lambda_n}{2} [\rcal(\Delta_{\mocal}) + \rcal(\Delta_{\mocalp})]. \end{align} </div> </div> <div class="lemma"> <div class="theorem-title">Lemma 4 in (Negahban et al., 2009) </div> <div class="theorem-contents"> If \( \fcal(\Delta) &gt; 0 \) for all vectors \( \Delta \in \mathbb{K}(\delta) \), then \( \| \hd \| \leq \delta \). </div> </div> <p>Note that this was similar to our previous analysis on restricted strong convexity where we only really need to consider error terms restricted to ( \ctriplet ) due to Lemma \ref{lemma:1}. Therefore, it suffices to show ( \fcal(\Delta) &gt; 0 ) to obtain a bound on ( | \hd | = | \thatlambda - \ts| ), which completes the proof of Theorem 1.</p> <p>Define \(\fcal : \R^p \to \R\) by</p> \[\begin{align} \fcal(\Delta) \coloneqq \lcal(\ts + \Delta) - \lcal(\ts) + \lambda_n \left\{ \rcal(\ts + \Delta) - \rcal(\ts) \right\}, \end{align}\] <p>and define the set</p> \[\begin{align} \mathbb{K}(\delta) \coloneqq \ctriplet \cap \left\{ \| \Delta \| = \delta \right\}. \end{align}\] <p>Take any \(\Delta \in \kbb\). Then</p> \[\begin{align} \fcal(\Delta) = &amp; \lcal(\ts + \Delta) - \lcal(\ts) + \lambda_n \left\{ \rcal(\ts + \Delta) - \rcal(\ts) \right\} \tag{by definition} \\ \geq &amp; \langle \nabla \lcal (\ts), \Delta \rangle + \kl \| \Delta \|^2 - \tl^2(\ts) + \lambda_n \left\{ \rcal(\ts + \Delta) - \rcal(\ts) \right\} \\ &amp; \qquad \text{(by restricted strong convexity: \(\delta \lcal(\Delta, \ts) \geq \kl \| \Delta \|^2 - \tl^2(\ts)\),} \\ &amp; \qquad \text{ and \( \delta \lcal(\Delta, \ts) = \lcal(\ts + \Delta) - \lcal(\ts) - \dotprod{\nabla \lcal(\ts)}{\Delta} \) ) } \\ \geq &amp; \langle \nabla \lcal (\ts), \Delta \rangle + \kl \| \Delta \|^2 - \tl^2(\ts) + \lambda_n \left\{ \rcal(\Delta_{\mocalp}) - \rcal(\Delta_{\mocal}) - 2 \rcal(\ts_{\mcal^{\perp}}) \right\} \\ &amp; \qquad \text{(by Lemma 3 in \cite{paper})}. \label{thm-deriv:1} \end{align}\] <p>We lower bound the first term as \(\langle \nabla \lcal (\ts), \Delta \rangle \geq - \frac{\lambda_n}{2} \rcal(\Delta)\):</p> \[\begin{align} | \langle \nabla \lcal (\ts), \Delta \rangle | \leq &amp; \rs(\nabla \lcal(\ts)) \rcal(\Delta) &amp; \text{(Cauchy-Schwarz using dual norms \( \rcal \) and \( \rs \))} \\ \leq &amp; \frac{\lambda_n}{2} \rcal(\Delta) &amp; \text{(Theorem \ref{thm:1} assumption: \( \lambda_n \geq 2 \rs (\nabla \lcal(\ts)) \))}, \end{align}\] <p>and hence,</p> \[\begin{align} \langle \nabla \lcal (\ts), \Delta \rangle \geq &amp; - \frac{\lambda_n}{2} \rcal(\Delta). \end{align}\] <p>So applying to (\ref{thm-deriv:1}),</p> \[\begin{align} \fcal(\Delta) \geq &amp; \kl \| \Delta \|^2 - \tl^2(\ts) + \lambda_n \left\{ \rcal(\Delta_{\mocalp}) - \rcal(\Delta_{\mocal}) - 2 \rcal(\ts_{\mcal^{\perp}}) \right\} - \frac{\lambda_n}{2} \rcal(\Delta) \\ \geq &amp; \kl \| \Delta \|^2 - \tl^2(\ts) + \lambda_n \left\{ \rcal(\Delta_{\mocalp}) - \rcal(\Delta_{\mocal}) - 2 \rcal(\ts_{\mcal^{\perp}}) \right\} - \frac{\lambda_n}{2} (\rcal(\Delta_{\mocalp}) + \rcal(\Delta_{\mocal})) \\ &amp; \qquad \text{(Triangle inequality: \( \rcal(\Delta) \leq \rcal(\Delta_{\mocalp}) + \rcal(\Delta_{\mocal}) \))} \\ = &amp; \kl \| \Delta \|^2 - \tl^2(\ts) + \lambda_n \left\{ \frac{1}{2}\rcal(\Delta_{\mocalp}) - \frac{3}{2}\rcal(\Delta_{\mocal}) - 2 \rcal(\ts_{\mcal^{\perp}}) \right\} \\ &amp; \qquad \text{(Moving terms in)} \\ \geq &amp; \kl \| \Delta \|^2 - \tl^2(\ts) + \lambda_n \left\{ - \frac{3}{2}\rcal(\Delta_{\mocal}) - 2 \rcal(\ts_{\mcal^{\perp}}) \right\} \\ &amp; \qquad \text{(Norms always non-negative)} \\ = &amp; \kl \| \Delta \|^2 - \tl^2(\ts) - \frac{\lambda_n }{2} \left\{ 3 \rcal(\Delta_{\mocal}) + 4 \rcal(\ts_{\mcal^{\perp}}) \right\} \label{eq:r-delta-lb} . \end{align}\] <p>To bound the term \(\rcal(\Delta_{\mocal})\), recall the definition of subspace compatibility:</p> \[\begin{align} \varPsi (\mcal) \coloneqq \sup_{u \in \mcal \setminus \left\{ 0 \right\}} \frac{\rcal(u)}{\| u \|}, \label{eq:r-delta-ub} \end{align}\] <p>and hence</p> \[\begin{align} \rcal(\Delta_{\mocal}) \leq \varPsi(\mocal) \| \Delta_{\mocal} \|. \end{align}\] <p>To upper bound \(\| \Delta_{\mocal} \|\), we have</p> \[\begin{align} \| \Delta_{\mocal} \| &amp; = \| \Pi_{\mocal} (\Delta) - \Pi_{\mocal}(0) \| &amp; \text{(Since \(0 \in \mocal \), \( \Pi_{\mocal}(0) = 0 \)) } \\ &amp; \leq \| \Delta - 0 \| &amp; \text{(Projection operator is non-expansive, see Equation \ref{eq:non-expansive})} \\ &amp; = \| \Delta \|, \end{align}\] <p>which substituting into Equation (\ref{eq:r-delta-ub}) gives</p> \[\begin{align} \rcal(\Delta_{\mocal}) \leq \varPsi(\mocal) \| \Delta \|. \end{align}\] <p>Now we can use this result to lower bound Equation \ref{eq:r-delta-lb}:</p> \[\begin{align} \fcal (\Delta) \geq &amp; \kl \| \Delta \|^2 - \tl^2(\ts) - \frac{\lambda_n }{2} \left\{ 3 \varPsi(\mocal) \| \Delta \| + 4 \rcal(\ts_{\mcal^{\perp}}) \right\}. \label{eq:strict-psd} \end{align}\] <p>The RHS of the inequality in Equation \ref{eq:strict-psd} has a strictly positive definite quadratic form in \(\| \Delta \|\), and hence by taking \(\| \Delta \|\) large, it will be strictly positive. To find such a sufficiently large \(\| \Delta \|\), write</p> \[\begin{align} a &amp; = \kl, \\ b &amp; = -\frac{3\lambda_n}{2} \varPsi (\mocal), \\ c &amp; = -\tau_{\lcal}^2 (\ts) - 2 \lambda_n \rcal(\ts_{\mcalp}), \\ \end{align}\] <p>such that we have</p> \[\begin{align} \fcal (\Delta) &amp; \geq a \| \Delta \|^2 + b \| \Delta \| + c. \end{align}\] <p>Then the square of the rightmost intercept is given by the squared quadratic formula</p> \[\begin{align} \| \Delta \|^2 &amp; = \left( \frac{-b + \sqrt{b^2 - 4ac}}{2a} \right)^2 \\ &amp; = \frac{b^2 - 2b\sqrt{b^2 - 4ac} + b^2 - 4ac}{4a^2} \\ &amp; = \frac{b^2 - 2ac - b\sqrt{b^2 - 4ac}}{2a^2} \\ &amp; \leq \frac{b^2 - 2ac}{2a^2} \label{eq:coarse-bound} \\ &amp; = \frac{b^2}{2a^2} - \frac{c}{a} \\ &amp; = \frac{9 \lambda_n^2 \varPsi (\mocal)}{8 \kl^2} + \frac{ \tau_{\lcal}^2 (\ts) + 2 \lambda_n \rcal(\ts_{\mcalp}) }{\kl} &amp; \text{(Substituting in \(a, b, c\))} \\ &amp; \leq \frac{9 \lambda_n^2 \varPsi (\mocal)}{\kl^2} + \frac{1}{\kl} \left\{ 2\tau_{\lcal}^2 (\ts) + 4 \lambda_n \rcal(\ts_{\mcalp}) \right\}. \end{align}\] <p>In \cite{paper}, they were able to show an upper bound of</p> \[\begin{align} \| \Delta \|^2 &amp; \leq \frac{9 \lambda_n^2 \varPsi (\mocal)}{\kl^2} + \frac{\lambda_n}{\kl} \left\{ 2\tau_{\lcal}^2 (\ts) + 4 \rcal(\ts_{\mcalp}) \right\}, \label{eq:ub} \end{align}\] <p>but I am unsure about how they managed to place the \(\lambda_n\) term on the \(\tl^2(\ts)\) term. It may be due to an overly coarse bound on my end applied in Equation \ref{eq:coarse-bound}, but it is still unclear to me how the \(\lambda_n\) term can be produced.</p> <p>With Equation \ref{eq:ub}, we can hence apply Lemma 4 in \cite{paper} to obtain the desired result that</p> \[\begin{align} \| \thatlambda - \ts \|^2 \leq 9 \frac{\lambda_n^2}{\kl^2} \Psi^2(\mocal) + \frac{\lambda_n}{\kl} \left( 2 \tl^2 (\ts) + 4 \rcal (\ts_{\mcal^{\perp}}) \right). \end{align}\] <p>This concludes the proof.</p> <h1 id="conclusion"> <a class="anchor" href="#conclusion" aria-hidden="true"><span class="octicon octicon-link"></span></a>Conclusion</h1> <p>In the proof of Theorem \ref{thm:1} in Section \ref{sec:thm1-proof}, we saw how the bound is derived from the two key ingredients of the decomposability of the regularizer, and restricted strong convexity of the loss function. The decomposability of the regularizer allowed us to ensure that the error vector \(\hd\) will stay in the set \(\ctriplet\). This condition is then required in Lemma 4 of \cite{paper}, which allows us to bound \(\| \hd \|\) given that \(\fcal(\Delta) &gt; 0\). In one of the steps where we were lower bounding \(\fcal(\Delta)\) in the proof, we made use of the properties of restricted strong convexity.</p> <p>Theorem \ref{thm:1} provides a family of bounds for each decomposable regularizer under the choice of \((\mcal, \mocalp)\). The authors of \cite{paper} were able to use Theorem \ref{thm:1} to rederive both existing known results, and also derive new results on low-rank matrix estimation using the nuclear norm, minimax-optimal rates for noisy matrix completion, and noisy matrix decomposition. The reader is encouraged to refer to \cite{paper} for more details on the large number of corrollaries of Theorem \ref{thm:1}.</p> <h1 id="slides"> <a class="anchor" href="#slides" aria-hidden="true"><span class="octicon octicon-link"></span></a>Slides</h1> <p>A condensed slide deck that introduces the key ideas of the post, but without any of the proofs is provided below.</p> <style>.pdf-embed-wrap-7a894e63-7f08-4975-b1f6-bb3b2cadfe2e{display:flex;flex-direction:column;width:100%;height:650px}.pdf-embed-container-7a894e63-7f08-4975-b1f6-bb3b2cadfe2e{height:100%}.pdf-embed-container-7a894e63-7f08-4975-b1f6-bb3b2cadfe2e iframe{width:100%;height:100%}</style> <div class="pdf-embed-wrap-7a894e63-7f08-4975-b1f6-bb3b2cadfe2e"> <div class="pdf-embed-container-7a894e63-7f08-4975-b1f6-bb3b2cadfe2e"> <iframe src="/assets/presentations/A-Unified-Framework-For-High-Dimensional-Analysis-Of-M-Estimators.pdf" frameborder="0" allowfullscreen=""></iframe> </div> </div> <h1 id="citations"> <a class="anchor" href="#citations" aria-hidden="true"><span class="octicon octicon-link"></span></a>Citations</h1> <ul> <li>Negahban, S., Yu, B., Wainwright, M. J., and Ravikumar, P. <a href="https://proceedings.neurips.cc/paper_files/paper/2009/file/dc58e3a306451c9d670adcd37004f48f-Paper.pdf" rel="external nofollow noopener" target="_blank">A unified framework for high-dimensional analysis of m-estimators with decomposable regularizers</a>. In Bengio, Y., Schuurmans, D., Lafferty, J., Williams, C., and Culotta, A. (eds.), Advances in Neural Information Processing Systems, volume 22. Curran Associates, Inc., 2009. URL https://proceedings.neurips.cc/paper_files/paper/2009/file/dc58e3a306451c9d670adcd37004f48f-Paper.pdf.</li> </ul> </article><div id="giscus_thread" style="max-width: 800px; margin: 0 auto;"> <script>let giscusTheme=localStorage.getItem("theme"),giscusAttributes={src:"https://giscus.app/client.js","data-repo":"fanpu/website","data-repo-id":"R_kgDOIpOodA","data-category":"General","data-category-id":"DIC_kwDOIpOodM4CTKDC","data-mapping":"title","data-strict":"0","data-reactions-enabled":"1","data-emit-metadata":"0","data-input-position":"top","data-theme":giscusTheme,"data-lang":"en",crossorigin:"anonymous",async:""},giscusScript=document.createElement("script");Object.entries(giscusAttributes).forEach(([t,e])=>giscusScript.setAttribute(t,e)),document.getElementById("giscus_thread").appendChild(giscusScript);</script> <noscript>Please enable JavaScript to view the <a href="http://giscus.app/?ref_noscript" rel="external nofollow noopener" target="_blank">comments powered by giscus.</a> </noscript> </div> </div> </div> <footer class="fixed-bottom"> <div class="container mt-0"> © Copyright 2023 Fan Pu Zeng. Powered by <a href="https://jekyllrb.com/" target="_blank" rel="external nofollow noopener">Jekyll</a> with <a href="https://github.com/alshedivat/al-folio" rel="external nofollow noopener" target="_blank">al-folio</a> theme. </div> </footer> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/js/bootstrap.bundle.min.js" integrity="sha256-fgLAgv7fyCGopR/gBNq2iW3ZKIdqIcyshnUULC4vex8=" crossorigin="anonymous"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js" integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/imagesloaded@4/imagesloaded.pkgd.min.js"></script> <script defer src="/assets/js/masonry.js" type="text/javascript"></script> <script type="text/javascript">$(function(){$('[data-toggle="tooltip"]').tooltip()});</script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.0.6/dist/medium-zoom.min.js" integrity="sha256-EdPgYcPk/IIrw7FYeuJQexva49pVRZNmt3LculEr7zM=" crossorigin="anonymous"></script> <script defer src="/assets/js/zoom.js"></script> <script defer src="/assets/js/common.js"></script> <script type="text/javascript">window.MathJax={loader:{load:["[tex]/mathtools"]},tex:{packages:{"[+]":["mathtools","ams"]}},options:{renderActions:{addMenu:[]}}};</script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js"></script> <script defer src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script> <script async src="https://www.googletagmanager.com/gtag/js?id=G-S3VHEYH05S"></script> <script>function gtag(){window.dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","G-S3VHEYH05S");</script> <script type="text/javascript">function progressBarSetup(){"max"in document.createElement("progress")?(initializeProgressElement(),$(document).on("scroll",function(){progressBar.attr({value:getCurrentScrollPosition()})}),$(window).on("resize",initializeProgressElement)):(resizeProgressBar(),$(document).on("scroll",resizeProgressBar),$(window).on("resize",resizeProgressBar))}function getCurrentScrollPosition(){return $(window).scrollTop()}function initializeProgressElement(){let e=$("#navbar").outerHeight(!0);$("body").css({"padding-top":e}),$("progress-container").css({"padding-top":e}),progressBar.css({top:e}),progressBar.attr({max:getDistanceToScroll(),value:getCurrentScrollPosition()})}function getDistanceToScroll(){return $(document).height()-$(window).height()}function resizeProgressBar(){progressBar.css({width:getWidthPercentage()+"%"})}function getWidthPercentage(){return getCurrentScrollPosition()/getDistanceToScroll()*100}const progressBar=$("#progress");window.onload=function(){setTimeout(progressBarSetup,50)};</script> <script src="https://cdn.jsdelivr.net/npm/anchor-js/anchor.min.js"></script> <script>anchors.add("h1, h2, h3");</script> </body> </html>